{"name":"Webstreams","tagline":"Serve APIs returning & consuming observable streams over WebSockets using .NET","body":"WebStreams\r\n===============\r\n<p align=\"center\">\r\n  <img src=\"https://github.com/daprlabs/WebStreamServer/blob/master/logo_icon.png\" />\r\n</p>\r\n\r\nServe APIs returning &amp; consuming observable streams over WebSockets using .NET\r\n\r\nThink of it as ASP.NET Web API but with controllers which return `IObservable<T>` instead of `Task<T>`, which allows you to easily push to clients. Controllers can also consume `IObservable<T>` parameters, see the [ChatController](https://github.com/daprlabs/WebStreamSamples/blob/master/ChatRoomController.cs) example.\r\n\r\n### Why not SignalR?\r\nSignalR is great for a lot of realtime applications which scaleout easily, but it's not easy to create realtime apps which require authoritative logic - take a game for example, or other complex apps. This is perhaps because SignalR gives you transparent scale-out, so the rendezvous point for notifications (Service Bus, SQL Server, etc) does not contain application logic.\r\n\r\nInstead, WebStreams does not give you transparent scale-out at all. Scale-out can easily be achieved using Service Bus or another backplane like in a SignalR app, but often scale-out will sit in Microsoft Orleans or another Actor framework.\r\nAnother option for scale-out is Azure Event Hubs, which can contain application logic.\r\n\r\nSee the [WebStreamSamples](https://github.com/daprlabs/WebStreamSamples) repository for a sample server with a Web client.\r\n\r\nTODO: publish sample which scales out app logic using Microsoft Orleans.\r\n\r\n## Installation\r\n```\r\nPM> Install-Package Dapr.WebStream.Server\r\n```\r\nNuGet will pull in all dependencies (Owin, Json.NET, Rx).\r\n\r\n## Usage\r\nCall UseWebStream() in your OWIN startup method. See below for an example.\r\n\r\nStockController.cs\r\n```\r\n[RoutePrefix(\"/stock\")]\r\npublic class StockTickerController\r\n{\r\n  private readonly ConcurrentDictionary<string, IObservable<Stock>> stocks =\r\n    new ConcurrentDictionary<string, IObservable<Stock>>();\r\n\r\n  [Route(\"ticker\")]\r\n  public IObservable<Stock> GetTicker(string symbol)\r\n  {\r\n    return this.GetStockTicker(symbol);\r\n  }\r\n  private static IObservable<Stock> CreateStockTicker(string symbol)\r\n  {\r\n    var random = new Random();\r\n    // Construct a shoddy, pseudo-random walk.\r\n    return\r\n      Observable.Interval(TimeSpan.FromSeconds(0.1))\r\n        .Select(time => random.NextDouble())\r\n        .Scan((double)random.Next(1000), (prev, randomVal) =>\r\n          Math.Max(0, prev * (1 + (0.01 * (randomVal - 0.5)))))\r\n        .Select(val => new Stock(symbol, val, DateTime.UtcNow));\r\n  }\r\n  private IObservable<Stock> GetStockTicker(string symbol)\r\n  {\r\n    return this.stocks.GetOrAdd(symbol, CreateStockTicker);\r\n  }\r\n}\r\n```\r\n\r\nIn your OWIN Startup.cs\r\n```\r\npublic void Configuration(IAppBuilder app)\r\n{\r\n    app.UseWebStream();\r\n}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}